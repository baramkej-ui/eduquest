/**
 * @description This ruleset enforces a strict user-ownership model for user-specific data and role-based access for global data.
 * All write operations are protected by authorization checks, while read access is carefully controlled based on the data's purpose and user roles.
 *
 * @dataStructure
 * - `/users/{userId}`: Stores user profiles, accessible only to the user themselves, or to anyone in a "admin" role.
 * - `/problems/{problemId}`: Stores educational problems, accessible to anyone for reading, but only writable by "admin" or "teacher" roles.
 * - `/users/{userId}/results/{resultId}`: Stores user-specific results. Only the user who owns the result can modify it.
 *
 * @keySecurityDecisions
 * - Users can only list their own results. Listing of all users is denied.
 * - The 'admin' role is all-powerful, bypassing many restrictions.
 * - Data types are not strictly enforced beyond what's necessary for authorization.
 *
 * @denormalizationForAuthorization
 * - The user ID is embedded in the path for the /users/{userId}/results/{resultId} collection, enabling path-based ownership checks without additional reads.
 *
 * @structuralSegregation
 * - Private user data is stored under /users/{userId}, while public problem data is stored in the top-level /problems collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user has the "admin" role.
     */
    function isAdmin() {
        return isSignedIn() && request.auth.token.role == 'admin';
    }

    /**
     * @description Checks if the authenticated user has the "admin" or "teacher" role.
     */
     function isAdminOrTeacher() {
        return isSignedIn() && (request.auth.token.role == 'admin' || request.auth.token.role == 'teacher');
     }

    /**
     * @description Checks if the user is the owner and the resource exists (for update/delete).
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /***************** Users Collection *****************/

    /**
     * @description Manages user profiles, ensuring only the user or an admin can read and write their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) if the user is signed in and owns the profile (userId matches auth.uid).
     * @allow (create) if the user is signed in and the userId matches auth.uid (self-creation).
     * @deny (create, update, delete) if the user is not signed in or does not own the profile.
     * @principle Enforces document ownership and authenticated access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false; // Listing users is not permitted.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) || isAdmin();
      allow delete: if isExistingOwner(userId) || isAdmin();
    }

    /***************** Problems Collection *****************/

    /**
     * @description Manages educational problems, allowing public read access but restricting write access to admins and teachers.
     * @path /problems/{problemId}
     * @allow (get, list) any signed in user can read problems.
     * @allow (create, update, delete) only admins and teachers can create, update, or delete problems.
     * @deny (create, update, delete) if the user is not an admin or a teacher.
     * @principle Public read access with role-based write control.
     */
    match /problems/{problemId} {
      allow get, list: if isSignedIn();
      allow create: if isAdminOrTeacher();
      allow update: if isAdminOrTeacher() && resource != null;
      allow delete: if isAdminOrTeacher() && resource != null;
    }

    /***************** User Results Subcollection *****************/

    /**
     * @description Manages user-specific results, ensuring only the user who owns the result (or an admin) can manage it.
     * @path /users/{userId}/results/{resultId}
     * @allow (get, list, create, update, delete) if the user is signed in and owns the parent profile (userId matches auth.uid).
     * @deny (create, update, delete) if the user is not signed in or does not own the parent profile.
     * @principle Enforces path-based ownership for user results.
     */
    match /users/{userId}/results/{resultId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}